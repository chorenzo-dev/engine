# Workspace Analysis Task

**Purpose**: Analyze the codebase at `{workspace_root}` and generate a comprehensive `analysis.json` file that identifies:
- Monorepo structure and workspace configuration
- CI/CD platform detection 
- All projects with their languages, types, frameworks, and dependencies
- Docker usage across projects

**Method**: Update `.chorenzo/analysis.json` incrementally AFTER EVERY FINDING to prevent information loss in large codebases.

**Output**: A complete analysis.json file that validates against the expected schema. You MUST run `npx chorenzo analysis validate` after completing the analysis. If validation fails, fix the issues and rewrite until validation passes.

---

## Tool Budget

You have a MAXIMUM of 3 tool rounds. Use them strategically:

Round 1: Identify and list ALL files needed for analysis, identify CI/CD files
Round 2: Read ALL files in a single batch
Round 3: Investigate findings from file contents (if needed)

Optional 4th round only in rare cases when absolutely necessary.

## Efficiency Strategy

1. Look at the file structure and identify ALL files needed at once
2. Read ALL of them in a SINGLE batch (Read tool supports multiple calls)
3. Use the third round to investigate any findings that need clarification
4. Never use Grep or search - just read the files directly

## Penalties

- ðŸš« Do NOT read the same file multiple times
- ðŸš« Do NOT make separate tool calls for files in the same directory
- ðŸš« Do NOT use more than 3 tool rounds unless absolutely necessary
- ðŸš« Ensure all fields, especially ciCd, are thoroughly handled and not overlooked

## CRITICAL Rules

- has_package_manager = true ONLY if project has dependencies listed in its config file. Empty dependencies = false.
- Check ALL relevant dependency sections (dependencies, devDependencies, peerDependencies, etc.)
- Determine ecosystem based on the package manager type

TASKS:

1. Find and read all configuration files (any package managers) for ACTUAL projects only
2. Determine ecosystems and dependencies from actual config content
3. Detect project type based on dependencies and file structure
4. Return ONLY valid JSON - no explanations, no markdown blocks, no additional text

## CRITICAL: Project vs Test Data Distinction

Only analyze ACTUAL projects, not test data, examples, or fixtures:

- **EXCLUDE**: test-fixtures/, examples/, sample/, templates/, demos/, **tests**/, spec/, test/
- **EXCLUDE**: Any directory that appears to contain example/test code rather than production code
- **INCLUDE**: Only directories that represent actual working projects or applications
- **ROOT PROJECT**: Only include root as a project if:
  - It has actual application dependencies (not just build tools/dev dependencies), OR  
  - It's a single project workspace (workspace has only one project)

Look for indicators that distinguish real projects from test data:

- Real projects: Have meaningful dependencies, proper structure, production-ready code
- Test data: Minimal configs, example code, fixture data, sample applications

IMPORTANT: Do NOT use `json` markdown blocks. Return raw JSON only.

## Language Detection Rules:

Detect the PRIMARY language for each project based on file extensions and patterns. Examples: `typescript` for .ts files or tsconfig.json, `python` for .py files, `java` for .java files, `csharp` for .cs files, `go` for .go files, etc. When multiple languages are present, choose the PRIMARY language that represents the main codebase.

## Project Type Detection Rules:

- **cli_tool**: Command-line applications that users interact with via terminal. Examples: commander (JS), click (Python), clap (Rust), cobra (Go)
- **web_app**: Frontend applications served to browsers. Examples: react/next (JS), django (Python), rails (Ruby), laravel (PHP)
- **api_server**: HTTP services providing REST/GraphQL APIs. Examples: express (JS), fastapi (Python), gin (Go), spring-boot (Java)
- **backend_service**: Background processors for queues, cron jobs, data processing. Examples: bull (JS), celery (Python), sidekiq (Ruby)
- **library**: Reusable code packages published to registries. Examples: npm packages, pip packages, cargo crates, maven artifacts
- **script**: Simple automation or utility scripts. Examples: build scripts, deployment scripts, data migration scripts
- **infrastructure**: Infrastructure-as-code and deployment configurations. Examples: terraform, kubernetes manifests, docker-compose
- **desktop_app**: Native desktop applications. Examples: electron (JS), tkinter (Python), javafx (Java), wpf (C#)
- **mobile_app**: Mobile applications for phones/tablets. Examples: react-native, flutter, native iOS/Android projects
- **unknown**: Cannot determine project type from available information

## Framework Detection:

For each project, identify the PRIMARY framework that defines the project's architecture and runtime environment. **IMPORTANT**: Verify the framework is actually used, not just listed as a dependency.

**Validation Required:**
- Don't assume framework presence in dependencies means it's used
- Verify detected framework is actively used by checking:
  - Project patterns correlate with framework patterns
  - Framework is actively used in codebase, not just listed as dependency
- Look for framework-specific files, configurations, or code patterns
- If framework is listed but not actively used, set to null

**General Principle:**
Look for the main architectural framework that provides the application structure, routing, and runtime environment. Examples across ecosystems:

- **Web Apps**: nextjs (JS), django (Python), rails (Ruby), laravel (PHP), spring-boot (Java)
- **API Servers**: express (JS), fastapi (Python), gin (Go), rails (Ruby), aspnet-core (C#)
- **CLI Tools**: commander (JS), click (Python), clap (Rust), cobra (Go)

**Context-Aware Detection:**
When multiple frameworks could apply, prioritize the one that defines the project's primary architecture:

- UI libraries (react, vue, angular) are NEVER the main framework - they are rendering libraries
- Build tools, bundlers, and utilities are NOT frameworks
- Look for frameworks that provide application structure, not just UI components
- For vanilla apps without architectural frameworks, set to null

**Common Mistakes to Avoid:**

- Don't list UI/component libraries as frameworks (react, vue, angular, etc.)
- Don't list utility libraries, build tools, or testing frameworks
- Don't list databases, ORMs, or data access layers
- Focus on what provides the application's core architecture and runtime
- Never assume dependency presence equals active usage

Set framework to null if no clear architectural framework is identified OR if the framework is not actively used.

## Docker Detection:

For each project, check if a Dockerfile exists. Set dockerized to true if present, false otherwise.

## CI/CD Detection:

To populate the ciCd field, you need to check the workspace root for CI/CD configuration files:

- **github_actions**: `.github/workflows/` with ANY .yml/.yaml files
- **gitlab_ci**: `.gitlab-ci.yml` exists
- **circleci**: `.circleci/config.yml` exists  
- **jenkins**: `Jenkinsfile` exists
- **travis_ci**: `.travis.yml` exists
- **azure_devops**: `.azure-pipelines.yml` or `azure-pipelines.yml` exists
- **none**: No CI/CD configuration files found

## Output:

Expected JSON structure:
{
"isMonorepo": boolean,
"hasWorkspacePackageManager": boolean,
"workspaceEcosystem": {{{ecosystems}}} | null,
"workspaceDependencies": string[],
"ciCd": {{{cicd_systems}}},
"projects": [
{
"path": string,
"language": string,
"type": {{{project_types}}},
"framework": string | null,
"dockerized": boolean,
"dependencies": string[],
"hasPackageManager": boolean,
"ecosystem": {{{ecosystems}}} | null
}
]
}
